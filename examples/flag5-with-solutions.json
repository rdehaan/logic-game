{
  "aux_program": "% Predicates for (adjacent) cells\ncell(R,C) :- setting(row(R)), setting(col(C)).\ndirection(left;right;up;down).\nmovement(R,C,R,C+1,right) :- cell(R,C), cell(R,C+1).\nmovement(R,C,R,C-1,left) :- cell(R,C), cell(R,C-1).\nmovement(R,C,R+1,C,down) :- cell(R,C), cell(R+1,C).\nmovement(R,C,R-1,C,up) :- cell(R,C), cell(R-1,C).\nadjacent(R1,C1,R2,C2) :- direction(D), movement(R1,C1,R2,C2,D).",
  "level_gen_program": "%%% Game played on an 8x6 grid\nsetting(grid_width(8)).\nsetting(grid_height(6)).\nsetting(row(1..H)) :- setting(grid_height(H)).\nsetting(col(1..W)) :- setting(grid_width(W)).\n\n%%% Time bound: 30 steps\nsetting(time_bound(30)).\n\n%%% Player and flag are randomly placed (but not too close)\n1 { at(R,C,player) : setting(row(R)), setting(col(C)) } 1.\n1 { at(R,C,flag) : setting(row(R)), setting(col(C)) } 1.\ndistance(D) :- at(R1,C1,player), at(R2,C2,flag),\n    D = |R1-R2| + |C1-C2|.\n:- distance(D), D <= 3.\n%%% Randomize level generation\n#heuristic at(RANDINT(1,6),RANDINT(1,8),player). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),flag). [10,true]\n\n% Visualization instructions\ndecorate(game_type,grid).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007).",
  "visibility_program": "%%% 'Fog-of-war' is a ring of one around the player\nobserve(fog(R1,C1)) :-\n    setting(row(R1)), setting(col(C1)),\n    at(R2,C2,player), |C1-C2| >= 2.\nobserve(fog(R1,C1)) :-\n    setting(row(R1)), setting(col(C1)),\n    at(R2,C2,player), |R1-R2| >= 2.\nobserve(at(R,C,O)) :- at(R,C,O), not observe(fog(R,C)).",
  "player_move_program": "% Make a plan once\n% consisting of several landmark locations\nremember(landmark(1,H-1,W-1)) :- observe(at(R,C,player)),\n    setting(grid_height(H)), setting(grid_width(W)),\n    not memory(made_plan).\nremember(landmark(2,2,2)) :- not memory(made_plan).\nremember(landmark(3,H-1,W-1)) :- observe(at(R,C,player)),\n    setting(grid_height(H)), setting(grid_width(W)),\n    not memory(made_plan).\nmemory(landmark(R,C)) :- remember(landmark(R,C)).\nremember(made_plan).\n\n% Once you've seen the flag, go grab it!\ndo(move(down)) :- observe(at(R1,C1,player)), observe(at(R2,C2,flag)), R1 < R2.\ndo(move(up)) :- observe(at(R1,C1,player)), observe(at(R2,C2,flag)), R1 > R2.\ndo(move(right)) :- observe(at(R,C1,player)), observe(at(R,C2,flag)), C1 < C2.\ndo(move(left)) :- observe(at(R,C1,player)), observe(at(R,C2,flag)), C1 > C2.\n\n% If you haven't seen the flag yet,\n% go to the next landmark that you haven't yet visited\ndo(move(down)) :- observe(at(R1,C1,player)),\n    not observe(at(_,_,flag)),\n    not memory(reached_landmark(I)),\n    memory(reached_landmark(J)) : memory(landmark(J,_,_)), J < I;\n    memory(landmark(I,R2,C2)), R1 < R2.\ndo(move(up)) :- observe(at(R1,C1,player)),\n    not observe(at(_,_,flag)),\n    not memory(reached_landmark(I)),\n    memory(reached_landmark(J)) : memory(landmark(J,_,_)), J < I;\n    memory(landmark(I,R2,C2)), R1 > R2.\ndo(move(right)) :- observe(at(R,C1,player)),\n    not observe(at(_,_,flag)),\n    not memory(reached_landmark(I)),\n    memory(reached_landmark(J)) : memory(landmark(J,_,_)), J < I;\n    memory(landmark(I,R,C2)), C1 < C2.\ndo(move(left)) :- observe(at(R,C1,player)),\n    not observe(at(_,_,flag)),\n    not memory(reached_landmark(I)),\n    memory(reached_landmark(J)) : memory(landmark(J,_,_)), J < I;\n    memory(landmark(I,R,C2)), C1 > C2.\n\n% Once you've reached a landmark, remember this\nremember(reached_landmark(I)) :-\n    observe(at(R,C,player)), memory(landmark(I,R,C)),\n    memory(reached_landmark(J)) : memory(landmark(J,_,_)), J < I.\nmemory(reached_landmark(I)) :- remember(reached_landmark(I)).",
  "nature_program": "% The player can do at most one action per time step\n:- do(X), do(Y), X != Y.\n\n% Effect of move(up;down;left;right): the player moves in the appropriate direction\nmove_result(R2,C2) :- do(move(D)), direction(D),\n    at(R1,C1,player), movement(R1,C1,R2,C2,D).\nnext(R,C,player) :- move_result(R,C).\nnext(R,C,player) :- at(R,C,player), not move_result(R',C') : cell(R',C').\n\n% The flag stays in place\nnext(R,C,flag) :- at(R,C,flag).",
  "goal_program": "%%% Goal: reach the flag\nwin :- at(R,C,player), at(R,C,flag).\n\n%%% You lose if time runs out..\nlose(timeout) :- current_time(T), setting(time_bound(S)), T >= S.",
  "level_state": "at(1,5,flag).\nat(2,1,player).",
  "level_settings": "setting(grid_width(8)).\nsetting(grid_height(6)).\nsetting(time_bound(30)).\nsetting(col(1)).\nsetting(col(2)).\nsetting(col(3)).\nsetting(col(4)).\nsetting(col(5)).\nsetting(col(6)).\nsetting(col(7)).\nsetting(col(8)).\nsetting(row(1)).\nsetting(row(2)).\nsetting(row(3)).\nsetting(row(4)).\nsetting(row(5)).\nsetting(row(6)).\ndecorate(game_type,grid).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007)."
}

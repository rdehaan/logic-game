{
  "aux_program": "% Predicates for (adjacent) cells\ncell(R,C) :- setting(row(R)), setting(col(C)).\ndirection(left;right;up;down).\nmovement(R,C,R,C+1,right) :- cell(R,C), cell(R,C+1).\nmovement(R,C,R,C-1,left) :- cell(R,C), cell(R,C-1).\nmovement(R,C,R+1,C,down) :- cell(R,C), cell(R+1,C).\nmovement(R,C,R-1,C,up) :- cell(R,C), cell(R-1,C).\nadjacent(R1,C1,R2,C2) :- direction(D), movement(R1,C1,R2,C2,D).\n\ncow(1..3).",
  "level_gen_program": "% The game is played on an 8x6 grid\n#const w=8.\n#const h=6.\n#const n=w*h.\nsetting(grid_width(w)).\nsetting(grid_height(h)).\nsetting(row(1..H)) :- setting(grid_height(H)).\nsetting(col(1..W)) :- setting(grid_width(W)).\n\n% Time bound: 200 steps\nsetting(time_bound(200)).\n\n% Player is randomly placed\n1 { at(R,C,player) : cell(R,C) } 1.\n% Flag is randomly placed\n1 { at(R,C,flag) : cell(R,C) } 1.\n% Cows are placed randomly\n1 { at(R,C,cow(C)) : cell(R,C) } 1 :- cow(C).\n% but not on player or flag\n:- at(R,C,cow(Cow)), at(R,C,player), cow(Cow).\n:- at(R,C,cow(Cow)), at(R,C,flag), cow(Cow).\n% Player and flag are not too close\n:- at(R1,C1,player), at(R2,C2,flag),\n    D = |R1-R2| + |C1-C2|, D <= 3.\n% Cows not too far from flag\n:- at(R1,C1,cow(Cow)), cow(Cow), at(R2,C2,flag),\n    D = |R1-R2| + |C1-C2|, D > 4.\n\n% Trees are placed at random\nn/4 { at(R,C,tree) : cell(R,C) }.\n% but not directly next to each other\n:- adjacent(R1,C1,R2,C2), at(R1,C1,tree), at(R2,C2,tree).\n% and not on top of the other items\n:- at(R,C,player), at(R,C,tree).\n:- at(R,C,flag), at(R,C,tree).\n:- at(R,C,cow(Cow)), at(R,C,tree), cow(Cow).\n% The flag is reachable for the player\nreachable(R,C) :- at(R,C,player).\nreachable(R1,C1) :- reachable(R2,C2), adjacent(R1,C1,R2,C2), not at(R1,C1,tree).\n:- cell(R,C), not at(R,C,tree), not reachable(R,C).\n% No empty 2x2 squares\n:- cell(R,C), cell(R+1,C+1),\n    not at(R,C,tree), not at(R,C+1,tree),\n    not at(R+1,C,tree), not at(R+1,C+1,tree).\n% No dead ends\n:- cell(R,C), not at(R,C,tree),\n    { not at(R',C',tree) : adjacent(R,C,R',C') } <= 1.\n\n% Randomize level generation\n#heuristic at(RANDINT(1,6),RANDINT(1,8),player). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),flag). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n#heuristic at(RANDINT(1,6),RANDINT(1,8),tree). [10,true]\n\n% Visualization info\ndecorate(game_type,grid).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007).\ndecorate(label,cow(Cow),font_f17c) :- cow(Cow).\ndecorate(label,tree,font_f1bb).\ndecorate(color,tree,green).\ndecorate(color,cow(Cow),hex_888888) :- cow(Cow).",
  "visibility_program": "% Everything is visible\nobserve(at(R,C,O)) :- at(R,C,O).",
  "player_move_program": "% Make a plan once,\n% consisting of a path towards the flag\npos_step(1..24) :-\n    not memory(made_plan).\n{ step(S) } :- pos_step(S),\n    not memory(made_plan).\n:- not step(1),\n    not memory(made_plan).\nstep(S-1) :- step(S), pos_step(S-1),\n    not memory(made_plan).\n1 { step(R,C,S) : cell(R,C) } 1 :- step(S),\n    not memory(made_plan).\n:- step(R1,C1,S), step(R2,C2,S+1), not adjacent(R1,C1,R2,C2),\n    not memory(made_plan).\n:- observe(at(R,C,tree)), step(R,C,S),\n    not memory(made_plan).\n:- observe(at(R,C,player)), not step(R,C,1),\n    not memory(made_plan).\n:- observe(at(R,C,flag)), step(R,C,S), step(S+1),\n    not memory(made_plan).\nmax_step(M) :- step(M), not step(M+1),\n    not memory(made_plan).\n:- max_step(S), observe(at(R,C,flag)), not step(R,C,S),\n    not memory(made_plan).\n% And remember the path\nremember(step(R,C,S)) :- step(R,C,S),\n    not memory(made_plan).\nremember(made_plan) :-\n    not memory(made_plan).\nmemory(step(R,C,S)) :- remember(step(R,C,S)).\nmemory(at_step(1)) :-\n    not memory(made_plan).\n\n% When making a plan, make sure to choose a cow-free path, if it exists\ncow_free_reachable(R,C) :- observe(at(R,C,flag)).\ncow_free_reachable(R2,C2) :-\n    cow_free_reachable(R1,C1),\n    adjacent(R1,C1,R2,C2), not observe(at(R2,C2,tree)),\n    not observe(at(R2,C2,cow(Cow))) : cow(Cow).\ncow_free_path_exists :- cow_free_reachable(R,C), observe(at(R,C,player)).\ncow_free_path_chosen :- not observe(at(R,C,cow(Cow))) : cow(Cow), step(R,C,S);\n    not memory(made_plan).\n:- not memory(made_plan),\n    cow_free_path_exists,\n    not cow_free_path_chosen.\n\n% Identify 'choke' points: where one can trap a cow blocking the flag\ndead_end(R,C) :- observe(at(R,C,flag)).\ndead_end(R2,C2) :-\n    dead_end(R1,C1), adjacent(R1,C1,R2,C2),\n    not observe(at(R2,C2,flag)),\n    2 { adjacent(R2,C2,R3,C3) :\n        adjacent(R2,C2,R3,C3),\n        not observe(at(R3,C3,tree))\n    } 2.\nchoke_point(R2,C2) :-\n    cell(R2,C2), not dead_end(R2,C2),\n    not observe(at(R2,C2,tree)),\n    adjacent(R1,C1,R2,C2), dead_end(R1,C1).\n\n% When making a plan, if no cow-free path exists,\n% make sure to visit at least one point that's neither 'choke' nor 'dead end'\nfree_point(R,C) :- cell(R,C),\n    not observe(at(R,C,tree)), not observe(at(R,C,flag)),\n    not dead_end(R,C), not choke_point(R,C).\nvisited(R,C) :- step(R,C,_).\n:- not memory(made_plan),\n    not cow_free_path_exists,\n    not free_point(R,C) : visited(R,C).\n\n% Heuristic: aim for short paths\n#heuristic step(S). [10,false]\n\n% Then follow the path to the flag\ndo(move(D)) :-\n    observe(at(R1,C1,player)),\n    memory(at_step(S)),\n    memory(step(R2,C2,S+1)),\n    movement(R1,C1,R2,C2,D),\n    not path_blocked.\nforget(at_step(S)) :-\n    memory(at_step(S)), S > 1,\n    not path_blocked.\nremember(at_step(S+1)) :-\n    memory(at_step(S)),\n    not path_blocked, not reset_needed.\n% But don't go onto a choke point if there is a cow blocking the path\nfuture_step(S2) :-\n    memory(at_step(S1)),\n    memory(step(R,C,S2)),\n    S2 >= S1.\nabout_to_enter_choke :-\n    memory(at_step(S)),\n    memory(step(R,C,S+1)),\n    choke_point(R,C).\npath_blocked :-\n    about_to_enter_choke,\n    future_step(S),\n    memory(step(R,C,S)),\n    observe(at(R,C,cow(Cow))).\n\n% Make a new plan when the current one doesn't/didn't work\nreset_needed :- not do(move(D)) : direction(D).\nreset_needed :- do(move(D1)), do(move(D2)), D1 != D2.\nreset_needed :- memory(at_step(S1)), memory(at_step(S2)), S1 != S2.\nforget(made_plan) :- reset_needed.\nforget(at_step(S)) :- reset_needed, pos_step(S).\nforget(step(R,C,S)) :- reset_needed, memory(step(R,C,S)).\n",
  "nature_program": "% Player can do at most one action per time step\ninvalid_move :- do(X), do(Y), X != Y.\ninvalid_move :- not do(move(D)) : direction(D).\nnext(R,C,player) :- invalid_move, at(R,C,player).\n\n% Effect of move(up;down;left;right): the player moves in the appropriate direction\nmove_result(R2,C2) :- do(move(D)), direction(D),\n    at(R1,C1,player), movement(R1,C1,R2,C2,D).\nplayer_stays(R,C) :- at(R,C,player), invalid_move.\nnext(R,C,player) :- move_result(R,C), not invalid_move.\nnext(R,C,player) :- at(R,C,player), not move_result(R',C') : cell(R',C').\n\n% The player can't run through trees\ninvalid_move :- move_result(R,C), at(R,C,tree).\n\n% Flag and trees stays in place\nnext(R,C,flag) :- at(R,C,flag).\nnext(R,C,tree) :- at(R,C,tree).\n\n% Cows wander around randomly\nseed(RANDINT(1,10000000000)).\n#const k=3. % constant to indicate 'inertia' of cows\ncow_choice(Cow,N) :- seed(S), cow(Cow),\n    CowSeed = (S / (100 ** Cow)),\n    Options = #count { cell(R2,C2) : \n        cell(R2,C2), at(R1,C1,cow(Cow)),\n        adjacent(R1,C1,R2,C2),\n        not at(R2,C2,tree), not at(R2,C2,flag)\n    },\n    N = CowSeed \\ (Options+k).\n% Mapping for cows' available moves\ncow_table(Cow,N,R1,C1) :- cow(Cow), cell(R1,C1),\n    N = #count { cell(R2,C2) :\n        cell(R2,C2), at(R3,C3,cow(Cow)),\n        adjacent(R3,C3,R2,C2),\n        not at(R2,C2,tree), not at(R2,C2,flag),\n        (R2,C2) < (R1,C1)\n    }.\n% Cows choose target location, based on randomness\ncow_target(Cow,R2,C2) :-\n    at(R1,C1,cow(Cow)), cow_choice(Cow,N), cow_table(Cow,N,R2,C2),\n    movement(R1,C1,R2,C2,D).\n% Cows move to target location, unless colliding with trees or other cows\n% (and unless colliding with the player who stays in place)\ncow_move(Cow,R,C) :- cow_target(Cow,R,C), cow(Cow),\n    not at(R,C,tree), not at(R,C,flag),\n    not cow_target(Cow',R,C) : cow(Cow'), Cow != Cow';\n    not cow_stays(Cow',R,C) : cow(Cow'), Cow != Cow';\n    not player_stays(R,C).\n% Otherwise, cows stay in place\ncow_stays(Cow,R,C) :- at(R,C,cow(Cow)), cow(Cow),\n    not cow_move(Cow,R',C') : cell(R',C').\n\n% Implement cows' movements\nnext(R,C,cow(Cow)) :- cow(Cow), cow_move(Cow,R,C).\nnext(R,C,cow(Cow)) :- at(R,C,cow(Cow)), cow(Cow),\n    cow_stays(Cow,R,C).\n\n% Player moves to their target, unless a cow is in the way\ninvalid_move :- move_result(R,C), cow_move(Cow,R,C), cow(Cow).\ninvalid_move :- move_result(R,C), cow_stays(Cow,R,C), cow(Cow).\ninvalid_move :- at(R1,C1,player), at(R2,C2,cow(Cow)), cow(Cow),\n    cow_target(Cow,R1,C1), move_result(R2,C2).",
  "goal_program": "% Goal: reach the flag\nwin :- at(R,C,player), at(R,C,flag).\n\n% You lose if time runs out..\nlose(timeout) :- current_time(T), setting(time_bound(S)), T >= S.",
  "level_state": "at(4,5,tree).\nat(1,4,tree).\nat(2,6,tree).\nat(6,5,tree).\nat(5,4,player).\nat(2,2,tree).\nat(4,2,tree).\nat(6,1,tree).\nat(5,3,tree).\nat(3,4,tree).\nat(3,7,tree).\nat(5,7,tree).\nat(1,8,tree).\nat(4,1,cow(1)).\nat(3,2,cow(2)).\nat(4,3,cow(3)).\nat(3,1,flag).",
  "level_settings": "setting(grid_width(8)).\nsetting(grid_height(6)).\nsetting(time_bound(200)).\nsetting(col(1)).\nsetting(col(2)).\nsetting(col(3)).\nsetting(col(4)).\nsetting(col(5)).\nsetting(col(6)).\nsetting(col(7)).\nsetting(col(8)).\nsetting(row(1)).\nsetting(row(2)).\nsetting(row(3)).\nsetting(row(4)).\nsetting(row(5)).\nsetting(row(6)).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007).\ndecorate(label,tree,font_f1bb).\ndecorate(color,tree,green).\ndecorate(color,cow(1),hex_888888).\ndecorate(color,cow(2),hex_888888).\ndecorate(color,cow(3),hex_888888).\ndecorate(label,cow(1),font_f17c).\ndecorate(label,cow(2),font_f17c).\ndecorate(label,cow(3),font_f17c).\ndecorate(game_type,grid)."
}
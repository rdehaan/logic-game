{
  "aux_program": "% Predicates for (adjacent) cells\ncell(R,C) :- setting(row(R)), setting(col(C)).\ndirection(left;right;up;down).\nmovement(R,C,R,C+1,right) :- cell(R,C), cell(R,C+1).\nmovement(R,C,R,C-1,left) :- cell(R,C), cell(R,C-1).\nmovement(R,C,R+1,C,down) :- cell(R,C), cell(R+1,C).\nmovement(R,C,R-1,C,up) :- cell(R,C), cell(R-1,C).\nadjacent(R1,C1,R2,C2) :- direction(D), movement(R1,C1,R2,C2,D).",
  "level_gen_program": "% The game is played on a 12x8 grid\n#const w=12.\n#const h=8.\n#const n=w*h.\nsetting(grid_width(w)).\nsetting(grid_height(h)).\nsetting(row(1..H)) :- setting(grid_height(H)).\nsetting(col(1..W)) :- setting(grid_width(W)).\n\n% Time bound: 100 steps\nsetting(time_bound(100)).\n\n% Player is randomly placed\n1 { at(R,C,player) : cell(R,C) } 1.\n% Flag is randomly placed\n1 { at(R,C,flag) : cell(R,C) } 1.\n% Attacker is placed at the flag\nat(R,C,attacker) :- at(R,C,flag).\n% Player and flag/attacker are not too close\nitem(player;flag;attacker).\ndistance(D,I1,I2) :- at(R1,C1,I1), at(R2,C2,I2),\n    item(I1), item(I2), I1 != I2,\n    D = |R1-R2| + |C1-C2|.\n:- distance(D,player,flag), D <= 3.\n\n% Trees are placed at random\nn/4 { at(R,C,tree) : cell(R,C) }.\n% but not directly next to each other\n:- adjacent(R1,C1,R2,C2), at(R1,C1,tree), at(R2,C2,tree).\n% and not on top of the other items\n:- at(R,C,player), at(R,C,tree).\n:- at(R,C,flag), at(R,C,tree).\n:- at(R,C,attacker), at(R,C,tree).\n% The flag is reachable for the player\nreachable(R,C) :- at(R,C,player).\nreachable(R1,C1) :- reachable(R2,C2), adjacent(R1,C1,R2,C2), not at(R1,C1,tree).\n:- cell(R,C), not at(R,C,tree), not reachable(R,C).\n% No empty 2x2 squares\n:- cell(R,C), cell(R+1,C+1),\n    not at(R,C,tree), not at(R,C+1,tree),\n    not at(R+1,C,tree), not at(R+1,C+1,tree).\n% No dead ends\n:- cell(R,C), not at(R,C,tree),\n    { not at(R',C',tree) : adjacent(R,C,R',C') } <= 1.\n\n% Randomize level generation\n#heuristic at(RANDINT(1,8),RANDINT(1,12),player). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),flag). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n#heuristic at(RANDINT(1,8),RANDINT(1,12),tree). [10,true]\n\n% Visualization info\ndecorate(game_type,grid).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007).\ndecorate(label,attacker,font_f17b).\ndecorate(label,tree,font_f1bb).\ndecorate(color,tree,green).\ndecorate(color,attacker,hex_8b0000).",
  "visibility_program": "% Everything is visible\nobserve(at(R,C,O)) :- at(R,C,O).",
  "player_move_program": "% Auxiliary predicates\nmax_path_length(M) :- setting(grid_width(W)), setting(grid_height(H)), M=2*W+2*H.\npath_length(0..M) :- max_path_length(M).\nmax_distance_to_attacker(R,C,0) :- cell(R,C), observe(at(R,C,attacker)).\nmax_distance_to_attacker(R1,C1,D) :-\n    cell(R1,C1), adjacent(R1,C1,R2,C2), not observe(at(R2,C2,tree)),\n    path_length(D), max_distance_to_attacker(R2,C2,D-1).\ndistance_to_attacker(R,C,D) :- max_distance_to_attacker(R,C,D),\n    not max_distance_to_attacker(R,C,D') : path_length(D'), D' < D.\nmax_distance_to_player(R,C,0) :- cell(R,C), observe(at(R,C,player)).\nmax_distance_to_player(R1,C1,D) :-\n    cell(R1,C1), adjacent(R1,C1,R2,C2), not observe(at(R2,C2,tree)),\n    path_length(D), max_distance_to_player(R2,C2,D-1).\ndistance_to_player(R,C,D) :- max_distance_to_player(R,C,D),\n    not max_distance_to_player(R,C,D') : path_length(D'), D' < D.\nmax_distance_to_flag(R,C,0) :- cell(R,C), observe(at(R,C,flag)).\nmax_distance_to_flag(R1,C1,D) :-\n    cell(R1,C1), adjacent(R1,C1,R2,C2), not observe(at(R2,C2,tree)),\n    path_length(D), max_distance_to_flag(R2,C2,D-1).\ndistance_to_flag(R,C,D) :- max_distance_to_flag(R,C,D),\n    not max_distance_to_flag(R,C,D') : path_length(D'), D' < D.\n\n% Strategy operates in several stages\nstage(1..4).\nremember(stage(1)) :- not memory(first_move_done), not wait_here.\nremember(stage(2)) :- not memory(first_move_done), wait_here.\nremember(first_move_done).\nmemory(stage(1)) :- remember(stage(1)).\nforget(stage(I)) :- memory(stage(I)), next_stage.\nremember(stage(I+1)) :- memory(stage(I)), next_stage.\n\n% Stage 0: select an appropriate waiting spot\n% (and a route towards it)\n\n% Wait in place if close to the attacker already ..\nwait_here :- observe(at(R,C,player)), distance_to_attacker(R,C,D), D <= 6,\n    not memory(first_move_done).\nwait(R,C,0) :- observe(at(R,C,player)), wait_here.\nmemory(chose_route) :- wait_here.\nremember(chose_route) :- wait_here.\n\n%% .. otherwise, wait somewhere else ..\nreachable(R,C,0) :- observe(at(R,C,player)), not memory(chose_route).\n{ route(R,C,D,I+1) : direction(D),\n                     movement(R,C,R',C',D), not observe(at(R',C',tree)) } 1 :-\n    reachable(R,C,I), path_length(I+1),\n    not memory(chose_route).\nreachable(R',C',I) :- route(R,C,D,I), movement(R,C,R',C',D),\n    not memory(chose_route).\n:- reachable(R,C,I), route(R',C',D,J), movement(R',C',R,C,D), J > I.\nwait(R,C) :- wait(R,C,I).\nwait_after(I) :- wait(R,C,I).\nwait(R,C,I) :- reachable(R,C,I), not route(R,C,D,I+1) : direction(D);\n    not memory(chose_route).\nremember(route(R,C,D)) :- route(R,C,D,_),\n    not memory(chose_route).\nmemory(route(R,C,D)) :- remember(route(R,C,D)),\n    not memory(chose_route).\nremember(wait(R,C)) :- wait(R,C).\nmemory(wait(R,C)) :- remember(wait(R,C)).\nremember(chose_route) :- not memory(chose_route).\n\n% .. don't go through a spot that's too close to the attacker ..\n:- reachable(R,C,I), max_distance_to_attacker(R,C,J), J < I.\n% .. don't take silly routes ..\n:- reachable(R,C,I), max_distance_to_player(R,C,J), J < I.\n% .. and take at least as many steps as a quarter of the distance\n% to the attacker..\n:- observe(at(R,C,player)),\n    distance_to_attacker(R,C,D),\n    HD = D/4, wait_after(W), W < HD,\n    not wait_here.\n\n% Stage 1: move to the waiting spot\ndo(move(D)) :- observe(at(R,C,player)), memory(route(R,C,D)),\n    memory(stage(1)).\nnext_stage :- observe(at(R,C,player)), memory(route(R,C,D)),\n    movement(R,C,R',C',D), memory(wait(R',C')),\n    memory(stage(1)).\n\n% Stage 2: wait for the attacker to get close\nnext_stage :-\n    observe(at(R,C,attacker)),\n    distance_to_player(R,C,D), D <= 3,\n    memory(stage(2)).\n\n% Stage 3: circle around\npossible_target(R',C') :-\n    observe(at(R,C,player)),\n    adjacent(R,C,R',C'), not observe(at(R',C',tree)),\n    memory(stage(3)), not perform(stage(4)).\nselect_target(R,C) :-\n    possible_target(R,C), distance_to_attacker(R,C,D),\n    max_distance_to_attacker(R',C',D) : possible_target(R',C'),\n        (R',C') != (R,C);\n    memory(stage(3)), not perform(stage(4)).\n1 { target(R,C) : select_target(R,C) } 1 :- memory(stage(3)).\ndo(move(D)) :- target(R',C'), observe(at(R,C,player)),\n    movement(R,C,R',C',D),\n    memory(stage(3)), not perform(stage(4)).\n\n% .. until closer to the flag than the attacker\nnext_stage :-\n    observe(at(R,C,flag)),\n    distance_to_player(R,C,D), distance_to_attacker(R,C,D'),\n    D < D',\n    memory(stage(3)).\n\n% Stage 4: run for the flag\nperform(stage(4)) :- memory(stage(3)), next_stage.\nperform(stage(4)) :- memory(stage(4)).\npossible_target(R',C') :-\n    observe(at(R,C,player)),\n    adjacent(R,C,R',C'), not observe(at(R',C',tree)),\n    perform(stage(4)).\nselect_target(R,C) :-\n    possible_target(R,C), distance_to_flag(R,C,D),\n    not max_distance_to_flag(R',C',D') : possible_target(R',C'),\n        path_length(D'), D' < D,\n        (R',C') != (R,C);\n    perform(stage(4)).\n1 { target(R,C) : select_target(R,C) } 1 :- perform(stage(4)).\ndo(move(D)) :- target(R',C'), observe(at(R,C,player)),\n    movement(R,C,R',C',D), perform(stage(4)).",
  "nature_program": "% Player can do at most one action per time step\ninvalid_move :- do(X), do(Y), X != Y.\nnext(R,C,player) :- invalid_move, at(R,C,player).\n\n% Effect of move(up;down;left;right): the player moves in the appropriate direction\nmove_result(R2,C2) :- do(move(D)), direction(D),\n    at(R1,C1,player), movement(R1,C1,R2,C2,D).\nnext(R,C,player) :- move_result(R,C).\nnext(R,C,player) :- at(R,C,player), not move_result(R',C') : cell(R',C').\n\n% The player can't run through trees\n:- next(R,C,player), at(R,C,tree).\n\n% Flag and trees stays in place\nnext(R,C,flag) :- at(R,C,flag).\nnext(R,C,tree) :- at(R,C,tree).\n\n%%% The attacker moves towards the player %%%\n\n% Auxiliary predicates\nmax_path_length(M) :- setting(grid_width(W)), setting(grid_height(H)), M=W+H.\npath_length(0..M) :- max_path_length(M).\nempty(R,C) :- cell(R,C), not at(R,C,tree).\n\n% Define possible moves for the attacker\npossible_target(PR,PC) :-\n    cell(PR,PC), empty(PR,PC),\n    at(R,C,attacker), adjacent(R,C,PR,PC).\n\n% Compute one that is on a shortest path to the player\nreachable_within(PR,PC,PR,PC,1) :- possible_target(PR,PC).\nreachable_within(PR,PC,R1,C1,I) :-\n    possible_target(PR,PC), path_length(I),\n    empty(R1,C1), reachable_within(PR,PC,R2,C2,I-1),\n    adjacent(R1,C1,R2,C2).\nselect_possible_target(PR,PC) :-\n    reachable_within(PR,PC,R,C,I), at(R,C,player),\n    not reachable_within(PR',PC',R,C,J) :\n        possible_target(PR',PC'), path_length(J), J < I.\ntarget(R,C) :- select_possible_target(R,C),\n    not select_possible_target(R',C') : cell(R',C'), (R',C') < (R,C).\n\n% Move towards it (if there are no exceptions)\nnext(R,C,attacker) :- target(R,C), not attacker_grabs_at(_,_).\n\n% Special case: the attacker catches the player if they try to swap places\nattacker_grabs_at(R,C) :- next(R,C,player),\n    at(R',C',player), target(R',C'), at(R,C,attacker).\nnext(R,C,attacker) :- attacker_grabs_at(R,C).",
  "goal_program": "% Goal: reach the flag\nwin :- at(R,C,player), at(R,C,flag).\n\n% You lose if the attacker catches you\nlose(caught) :- at(R,C,player), at(R,C,attacker).\n\n% You lose if time runs out..\nlose(timeout) :- current_time(T), setting(time_bound(S)), T >= S.",
  "level_state": "at(6,8,tree).\nat(7,11,player).\nat(1,1,tree).\nat(3,2,tree).\nat(5,2,tree).\nat(7,2,tree).\nat(2,3,tree).\nat(4,4,tree).\nat(6,4,tree).\nat(8,4,tree).\nat(1,5,tree).\nat(3,5,tree).\nat(5,6,tree).\nat(7,6,tree).\nat(2,7,tree).\nat(4,7,tree).\nat(8,8,tree).\nat(1,9,tree).\nat(3,9,tree).\nat(5,9,tree).\nat(7,10,tree).\nat(2,11,tree).\nat(4,11,tree).\nat(6,11,tree).\nat(8,12,tree).\nat(8,1,attacker).\nat(8,1,flag).",
  "level_settings": "setting(grid_width(12)).\nsetting(grid_height(8)).\nsetting(time_bound(100)).\nsetting(col(1)).\nsetting(col(2)).\nsetting(col(3)).\nsetting(col(4)).\nsetting(col(5)).\nsetting(col(6)).\nsetting(col(7)).\nsetting(col(8)).\nsetting(col(9)).\nsetting(col(10)).\nsetting(col(11)).\nsetting(col(12)).\nsetting(row(1)).\nsetting(row(2)).\nsetting(row(3)).\nsetting(row(4)).\nsetting(row(5)).\nsetting(row(6)).\nsetting(row(7)).\nsetting(row(8)).\ndecorate(game_type,grid).\ndecorate(label,flag,font_f024).\ndecorate(label,player,font_f007).\ndecorate(label,attacker,font_f17b).\ndecorate(label,tree,font_f1bb).\ndecorate(color,tree,green).\ndecorate(color,attacker,hex_8b0000)."
}
